// --- Constants ---
const PHISHING_RULESET_ID = "phishing_ruleset";
const UPDATE_ALARM_NAME = "daily_patch_check";

// REPLACE THIS with your actual raw GitHub URL for the updates file
const PATCH_URL = "https://raw.githubusercontent.com/YOUR_USER/YOUR_REPO/main/rulesets/updates.json";

let isEnabled = true;

// --- 1. Lifecycle & Initialization ---

chrome.runtime.onInstalled.addListener(async (details) => {
    // CASE A: First Install
    if (details.reason === 'install') {
        await chrome.storage.local.set({ isEnabled: true });
    }
    // CASE B: Extension Update (The user got a new version from the Store)
    else if (details.reason === 'update') {
        console.log("Extension updated. Clearing old patch rules...");
        // Clear the "Scratchpad" because the new Base likely contains these rules now
        const currentRules = await chrome.declarativeNetRequest.getDynamicRules();
        const currentIds = currentRules.map(rule => rule.id);
        if (currentIds.length > 0) {
            await chrome.declarativeNetRequest.updateDynamicRules({
                removeRuleIds: currentIds
            });
        }
    }

    // Always apply state and schedule the patch checker
    loadStateAndApply();
    chrome.alarms.create(UPDATE_ALARM_NAME, { periodInMinutes: 1440 }); // 24 Hours
});

chrome.runtime.onStartup.addListener(() => {
    loadStateAndApply();
});

// --- 2. Alarms (The Daily Update Check) ---

chrome.alarms.onAlarm.addListener((alarm) => {
    if (alarm.name === UPDATE_ALARM_NAME) {
        console.log("Checking for patches from GitHub...");
        checkForUpdates();
    }
});

// --- 3. Message Handling ---

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (message.command === 'updateState') {
        loadStateAndApply();
    } else if (message.command === 'whitelistTemporarily') {
        addTemporaryAllowRule(message.url)
            .then(() => sendResponse({ success: true }));
        return true;
    } else if (message.command === 'forceUpdate') {
        // Optional: If you want a "Check for Updates" button in your popup
        checkForUpdates().then((count) => sendResponse({ count }));
        return true;
    }
});

// --- 4. Core Logic ---

async function loadStateAndApply() {
    const { isEnabled: storedIsEnabled } = await chrome.storage.local.get('isEnabled');
    isEnabled = storedIsEnabled !== false;

    console.log(`State Loaded: Enabled: ${isEnabled}`);
    applyBlockingMode();
}

async function applyBlockingMode() {
    // Note: This only toggles the STATIC base. 
    // Dynamic rules (patches) are always "loaded" but we can assume 
    // if isEnabled is false, the user wants everything off.
    // However, DNR doesn't have a "disable dynamic rules" toggle easily.
    // Usually, toggling the Static Base is enough for the user to feel "Off".

    if (!isEnabled) {
        console.log("Protection OFF (Disabling Static Base).");
        await chrome.declarativeNetRequest.updateEnabledRulesets({
            disableRulesetIds: [PHISHING_RULESET_ID]
        });
    } else {
        console.log("Protection ON (Enabling Static Base).");
        await chrome.declarativeNetRequest.updateEnabledRulesets({
            enableRulesetIds: [PHISHING_RULESET_ID]
        });
    }
}

// --- 5. The Patching Logic (Dynamic Rules) ---

async function checkForUpdates() {
    if (!isEnabled) return; // Don't update if turned off

    try {
        const response = await fetch(PATCH_URL);
        if (!response.ok) throw new Error("Failed to fetch updates");

        // This JSON should be an array of DNR rule objects generated by your server/action
        const newRules = await response.json();

        // SAFETY CHECK: The 5,000 Rule Limit
        if (newRules.length > 5000) {
            console.warn("Too many updates for the patch system! Waiting for Store update.");
            // Optionally: Set a badge on the icon to tell user to update?
            return 0;
        }

        // Get existing dynamic rules to clear them (we overwrite the patch set)
        const oldRules = await chrome.declarativeNetRequest.getDynamicRules();
        const oldIds = oldRules.map(r => r.id);

        await chrome.declarativeNetRequest.updateDynamicRules({
            removeRuleIds: oldIds,
            addRules: newRules
        });

        console.log(`Applied patch with ${newRules.length} rules.`);
        return newRules.length;

    } catch (error) {
        console.error("Error fetching updates:", error);
        return 0;
    }
}

// --- 6. Proceed Button Logic ---

async function addTemporaryAllowRule(domain) {
    const sessionRules = await chrome.declarativeNetRequest.getSessionRules();
    const nextId = sessionRules.length > 0
        ? Math.max(...sessionRules.map(r => r.id)) + 1
        : 1;

    const urlFilter = "||" + domain + "^";

    await chrome.declarativeNetRequest.updateSessionRules({
        addRules: [{
            "id": nextId,
            "priority": 2, // Higher priority than static (1) and dynamic (1)
            "action": { "type": "allow" },
            "condition": {
                "urlFilter": urlFilter,
                "resourceTypes": ["main_frame"]
            }
        }]
    });
    console.log(`Temporarily allowed: ${domain}`);
}